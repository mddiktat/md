<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dictation → Arztbrief</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; max-width: 980px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 12px 0; }
    button { padding: 10px 14px; border: 1px solid #ccc; background: #fff; border-radius: 10px; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    select, input[type="text"] { padding: 10px 12px; border: 1px solid #ccc; border-radius: 10px; }
    .status { padding: 10px 12px; border: 1px solid #e5e5e5; background: #fafafa; border-radius: 10px; }
    textarea { width: 100%; min-height: 360px; padding: 12px; border: 1px solid #ccc; border-radius: 12px;
               font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .small { color: #555; font-size: 12px; }
    .pill { display: inline-block; padding: 3px 8px; border-radius: 999px; border: 1px solid #ddd; background: #fff; font-size: 12px; }
    .warn { border-color: #f2c200; background: #fff9db; }
    .ok { border-color: #2fb344; background: #ebfbee; }
    .err { border-color: #fa5252; background: #fff5f5; }
  </style>
</head>
<body>
  <h1>Medical Dictation → Copy-ready Brief</h1>

  <div class="row">
    <span class="small">Backend URL:</span>
    <input id="backendUrl" type="text" size="50" />
    <span class="pill">POST /dictate</span>
  </div>

  <div class="row">
    <span class="small">Microphone:</span>
    <select id="micSelect"></select>

    <button id="btnInit">Enable Mic</button>
    <button id="btnStart" disabled>Start (max 5 min)</button>
    <button id="btnStop" disabled>Stop</button>

    <span id="timer" class="pill">00:00</span>
    <span id="codec" class="pill">codec: —</span>
  </div>

  <div id="status" class="status warn">Click <b>Enable Mic</b> first.</div>

  <div class="row">
    <button id="btnCopy" disabled>Copy brief</button>
    <button id="btnClear">Clear</button>
  </div>

  <textarea id="output" placeholder="Your brief appears here..." spellcheck="false"></textarea>

<script>
(() => {
  const DEFAULT_BACKEND_BASE = "https://web-production-2ecad.up.railway.app";
  const MAX_SECONDS = 5 * 60;

  const REQUIRED_SECTIONS = [
    "Anamnese:",
    "Klinische Untersuchung:",
    "Bildgebung:",
    "Therapie:",
  ];

  const backendUrlEl = document.getElementById("backendUrl");
  const micSelect = document.getElementById("micSelect");
  const btnInit = document.getElementById("btnInit");
  const btnStart = document.getElementById("btnStart");
  const btnStop = document.getElementById("btnStop");
  const btnCopy = document.getElementById("btnCopy");
  const btnClear = document.getElementById("btnClear");
  const statusEl = document.getElementById("status");
  const outputEl = document.getElementById("output");
  const timerEl = document.getElementById("timer");
  const codecEl = document.getElementById("codec");

  backendUrlEl.value = DEFAULT_BACKEND_BASE;

  let stream = null;
  let recorder = null;
  let chunks = [];
  let tick = null;
  let seconds = 0;

  function setStatus(msg, kind="warn") {
    statusEl.className = `status ${kind}`;
    statusEl.innerHTML = msg;
  }

  function fmtTime(s) {
    const mm = String(Math.floor(s / 60)).padStart(2, "0");
    const ss = String(s % 60).padStart(2, "0");
    return `${mm}:${ss}`;
  }

  function pickMimeType() {
    const candidates = [
      "audio/webm;codecs=opus",
      "audio/webm",
      "audio/ogg;codecs=opus",
      "audio/ogg",
    ];
    for (const t of candidates) {
      if (window.MediaRecorder && MediaRecorder.isTypeSupported(t)) return t;
    }
    return "";
  }

  async function listMics() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const mics = devices.filter(d => d.kind === "audioinput");

    micSelect.innerHTML = "";
    if (mics.length === 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "No microphones found";
      micSelect.appendChild(opt);
      micSelect.disabled = true;
      return;
    }
    micSelect.disabled = false;

    mics.forEach((m, i) => {
      const opt = document.createElement("option");
      opt.value = m.deviceId;
      opt.textContent = m.label || `Microphone ${i + 1}`;
      micSelect.appendChild(opt);
    });
  }

  async function enableMic() {
    try {
      setStatus("Requesting microphone permission…", "warn");

      const deviceId = micSelect.value || undefined;
      const constraints = { audio: deviceId ? { deviceId: { exact: deviceId } } : true };

      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      await listMics();

      btnStart.disabled = false;
      setStatus("Mic ready. Click <b>Start</b> to record.", "ok");
    } catch (e) {
      console.error(e);
      setStatus(`Mic permission failed: <code>${e?.message || e}</code>`, "err");
      btnStart.disabled = true;
    }
  }

  function startTimer() {
    seconds = 0;
    timerEl.textContent = fmtTime(seconds);
    tick = setInterval(() => {
      seconds += 1;
      timerEl.textContent = fmtTime(seconds);
      if (seconds >= MAX_SECONDS) stopRecording(true);
    }, 1000);
  }

  function stopTimer() {
    if (tick) clearInterval(tick);
    tick = null;
  }

  function ensureAllSections(text) {
    let out = (text || "").trim();
    for (const s of REQUIRED_SECTIONS) {
      if (!out.includes(s)) out += `\n\n${s}\nnicht diktiert`;
    }
    return out.trim();
  }

  function normalizeBaseUrl(raw) {
    let base = (raw || "").trim().replace(/\/+$/, "");
    if (!/^https?:\/\//i.test(base)) base = "https://" + base;
    return base;
  }

  async function startRecording() {
    if (!stream) {
      setStatus("Mic not enabled. Click <b>Enable Mic</b> first.", "warn");
      return;
    }

    const mimeType = pickMimeType();
    codecEl.textContent = `codec: ${mimeType || "browser default"}`;

    chunks = [];
    try {
      recorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
    } catch (e) {
      console.error(e);
      setStatus(`MediaRecorder failed: <code>${e?.message || e}</code>`, "err");
      return;
    }

    recorder.ondataavailable = (ev) => {
      if (ev.data && ev.data.size > 0) chunks.push(ev.data);
    };

    recorder.onstop = async () => {
      stopTimer();
      btnStart.disabled = false;
      btnStop.disabled = true;

      const blob = new Blob(chunks, { type: recorder.mimeType || "audio/webm" });
      setStatus(`Uploading audio (${(blob.size/1024/1024).toFixed(2)} MB)…`, "warn");

      try {
        const base = normalizeBaseUrl(backendUrlEl.value);
        const endpoint = `${base}/dictate`;

        const fd = new FormData();
        const filename = blob.type.includes("ogg") ? "audio.ogg" : "audio.webm";
        fd.append("audio", blob, filename);

        // ✅ CORS-safe fetch (fixes "Failed to fetch")
        const res = await fetch(endpoint, {
          method: "POST",
          mode: "cors",
          credentials: "omit",
          body: fd
        });

        if (!res.ok) {
          const t = await res.text().catch(() => "");
          throw new Error(`HTTP ${res.status} ${res.statusText} ${t ? ("— " + t.slice(0, 200)) : ""}`);
        }

        const data = await res.json();
        const brief = ensureAllSections(String(data.text || ""));

        outputEl.value = brief;
        btnCopy.disabled = !brief;
        setStatus("Done. Brief is ready to copy.", "ok");
      } catch (e) {
        console.error(e);
        setStatus(`Upload/processing failed: <code>${e?.message || e}</code>`, "err");
      }
    };

    recorder.start();
    btnStart.disabled = true;
    btnStop.disabled = false;
    btnCopy.disabled = true;
    setStatus("Recording… Click <b>Stop</b> when finished.", "warn");
    startTimer();
  }

  function stopRecording(auto=false) {
    if (!recorder) return;
    try {
      recorder.stop();
      setStatus(auto ? "Max length reached. Stopping…" : "Stopping… Processing…", "warn");
    } catch (e) {
      console.error(e);
      setStatus(`Stop failed: <code>${e?.message || e}</code>`, "err");
    }
  }

  async function copyBrief() {
    const text = outputEl.value.trim();
    if (!text) return;
    try {
      await navigator.clipboard.writeText(text);
      setStatus("Copied to clipboard ✅", "ok");
    } catch {
      outputEl.focus();
      outputEl.select();
      document.execCommand("copy");
      setStatus("Copied (fallback) ✅", "ok");
    }
  }

  btnInit.addEventListener("click", enableMic);
  btnStart.addEventListener("click", startRecording);
  btnStop.addEventListener("click", () => stopRecording(false));
  btnCopy.addEventListener("click", copyBrief);
  btnClear.addEventListener("click", () => {
    outputEl.value = "";
    btnCopy.disabled = true;
    setStatus("Cleared.", "warn");
  });

  micSelect.addEventListener("change", enableMic);
  navigator.mediaDevices?.addEventListener?.("devicechange", listMics);

  listMics().catch(() => {});
})();
</script>
</body>
</html>
